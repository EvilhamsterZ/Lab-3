#include <iostream>
#include <Windows.h>//библиотека для русского ввода/вывода
#include <string> //стринговая библиотека
#include <sstream>

int main()
{
    SetConsoleCP(1251);//русский ввод
    SetConsoleOutputCP(1251);//вывод
    int p;
    int h = 0;//если не занулить не работает
    int n;
    int o;
    char c;//для символа строки
    std::string s = "Результат: ";
    std::string m;//сама строка
    std::string z;//сама строка
    std::string l = "абвгдеёжзийклмнопрстуфхцчшщъыьэюя";

    std::cout << "Введите шаг шифрования n= ";
    std::cin >> n;
    std::cout << "Введите строку для шифрования " << std::endl;
    std::cin >> z;// столкнулся с проблемой гетлайн пропускает первое слово. для этого использовал конструкцию конкатенации строк з и м где м считывает до пробела а м после.
    std::getline(std::cin, m);
    m = z + m;

    std::string::iterator end_pos = std::remove(m.begin(), m.end(), ' ');
    m.erase(end_pos, m.end());//чистим пробелы из строки
    std::cout << m << std::endl;//проверка чистки пробелов получается строка для шифровки не думаю что будет лишним показать что шифруется
    p = m.length();//для цикла, немного экономим память
    for (int i = 0; i < p; i++)
    {
        c = m[i];//берем итый символ
        h = l.find_first_of(c);//ищем символ в строке алфавита
        o = n + h;//добавляем шаг кодировки найденному номеру символа алфавита
        if (o > 33)//если символ превысит алфавит то начинаем с абв снова
        {
            o -= 33;
        }
        m[i] = l[o];//присваиваем итому значению новый символ
        h = 0;
    }
    std::cout << m << std::endl;
    return 0;
}

